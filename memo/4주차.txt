w4.txt(3월25일 수업)
1.지난시간 질문
	질문1) grade에 sort ->uniq을 했는데 왜 A가 남아있냐?
	-> field를 자르고 나서 uniq를 해야 한다. 그래야 uniq가 원하는대로 먹힌다,
	-> 이것은 알파벳 중복없이 정렬해서 출력하는 코드와 같다,

	질문2)  sort grades | cut –f1 | uniq –c | sort 와 sort grades | cut –f1 |
	uniq –c | sort –n이 왜 결과가 같으냐?
	sort –n : string ->num 로 치환하는 친구
	1, 11, 111, 2/1,11,111,12,2,23( string으로  인식하는 경우)
	1,2,11,111(숫자로 인식하는 경우) 

2.<git 정리 >
	1.git add example(그냥 파일)	2.status채크 :git status ->new file생김 = 스테이지 가 된 것
	3.  그다음 커밋:git commit ->어떤 txt 파일이 뜬다.

	                              ↓

	Q) GIT에서 여러 파일을 한꺼번에 스테이징 하기
	1) git add .
	2) git commit -> 어떤 txt파일이 뜨는데 이걸 안 뜨게 하고 싶다.
	:git commit –m “your msg”

	*매수업에 커밋으로 파일을 저장하는 연습하기 
	*git초기화 해야 git시작됨  
===========:git과 vi는 다른거다.git은 지금까지 한걸 저장하는거고vi는 열고 수정하고 닫고 
3. 문서 편집기 ex) vi, vim ,emacs, notepad++...
 1)문서 편집기의 역할: 프롬포트에서 파일을 직접 편집할수 있게 해주는 툴
 
 2) 문서 편집기의 유형
 ㄱ.vi(visual editor의약자) :
 ㄴ.vim(vi improved의 약자) :vi보다 더 많은 기능 제공(정규표현식,...)
 
3) 문서 편집기의 특징
 ㄱ. 화면 단위 편집기: 열었을 때 한줋한줄 뜨는게 아니라 화면 전체에 다 나오는 것
 ㄴ.유닉스 계열에서 가장 많이 사용함
 ㄷ.택스트 편집 기능만 제공함 
 ㄹ.less처럼 어딘가에 들어갔다가 빠져 나오는 역할
*vi 로 파일을 연다 q, 바꾸고 저장하고 할 일한다, 간단한 조회 같은 거는 head를쓴다,


4)모드 
 ㄱ . 모드 사이클 :일반모드 <->입력모드<->명령모드 (ESC로 모드 전환) 
 ㄴ.입력 모드(어디에서 입력을 시작 할 것인가)
 ㄱ)  i –현커서에서 입력 ㄴ)  a – 현 커서 한 칸 뒤에서 입력 ㄷ) o – 한줄 추가후 입력 
 ㄷ. 명령모드 
        - 단축키(?)“ :wq!+ enter ”(w:write,q:quit,!:강제적으로 하는 것)
	-파일저장, 덮어쓸건지, 빠져나갈건지 등(파일 안이 아니라 밖에서 어떻게 할건지...) 

5)실습하기: 파일아무거나 열어서 수정하고 저장하고 나오기
 ㄱ.처음에 vi +파일명 하고 텍스트 열었을 때는 일반모드 이때는 입력이 되지 않는다.
 ㄴ.a,i,o중   뭔가를 누르면 입력모드가 된다.
 ㄷ.esc 눌러 명령모드 진입, 이제  쓸수가 없음 “:wq!+enter”로  파일 빠져나갈 것 
 *vi가 기존에디터로 세팅이 안되는 사람들이 한번 치고 그다음에는 한처도 되는 명령어
-> set –o vi ->이게 안되면 $HOME/.bashrc로 가라 

6)나의 질문
Q1).일반모드->입력모드 일때는 esc로 모드 전환 되는 것이 아닌가?Q2). 명령모드->일반모드로 갈때는 ?

*일반모드에서는 q를 쳐서 나온다,

4.패턴매칭(grep애서 배웠다????)= *
- 프롬포트에서 셸과 프로그램이 작동한다.

4.패턴 매칭( 특정한 단어를 가진 파일을 찾는 것, 패턴매칭을 할때쓰는 기호가 와일드 카드/와일드카드:파일 이름이나 텍스트에서 특정한 패턴을 대체하거나 일치시키기 위해 사용되는 특별한 문자 ex) *,?)
 -> 프롬포트와 셸의 차이 어떤부분을 셸이 맞는지 알것
 1)셸
ㄱ.프롬프트에서 셸과 프로그램이 작동한다.
   grep Linux sample.txt(grep은 프로그래밍이 맞지만, 나머지, sample에 리눅스가 있는지 없는지는 셸이 하는 것)
 ㄴ.프롬포트는 우리가 명령을 실행하는 곳
ㄷ.셸: 사용자와 리눅스 운영체제를 연결해주는 매개체
- 리눅스 – 셸, 프롬포트 - 사용자(나)
ㄹ.셸의 역할: 명령실행 / 와일드카드 처리.(패턴매칭에 어떤 와일드카드라는 것을 썼을떄 걔를 원래 것으로 바꿔어서 프롬포트 한테 보낸다) / 파이프라인 처리(결과물을 입력으로 보내는역할, ex)  -head xxx | grep | ....)


 ㄹ.셸의 역할
grep Linux *.txt(*모든 txt파일에서 Linux를 찾아라 할 때 쓰는 와일드 카드 =*)
 이때 셸의 역할:*.txt-> sample.txt,a.txt,.....등등등을 목록으로 만든다. = 셸이 패턴매칭을 처리하여 결과물을 프로그램에 보낸다.(= 즉, 와일드카드를 셸이 리터럴 값으로 변경해준다)

ㅁ. 와일드 카드 : 각각의 와일드 카드가 패턴을 어떻게 매칭 시킬것인가?
 < * >
 ㄱ)zero or more : 0개 이상의 연속열과 일치하는 
     a.“zero": 해당 패턴이 전혀 없는 경우를 포함합니다.
     b. "more": 해당 패턴이 한 번 이상 나타나는 경우를 포함합니다.
     c. 예시
	ex1) "abc*" : "ab", "abc", "abcc", "abccc", 등과 같은 문자열과 일치합니다. 여기서 "*"는 "c" 문자가 0개 이상 나타날 수 있음을 나타냅니다. 따라서 "abc", "abcc", "abccc"와 같은 문자열도 해당 패턴에 일치합니다.
	ex2) *.txt: .txt, animals.txt = 뭔가 앞에 있고 txt라는 확장자로 끝나는것                  / a.txtt(x) 

< ? >
ㄱ. 한자리/ 두자리 수 매칭
   a. grep Linux ch ? : ch1 ch2 ch3 ....ch100 의 파일중 한자리수만 매칭 되는 것이다.
   b. grep Linux ch ?? :  ch1 ch2 ch3 ....ch100 의 파일중 두자리수만 매칭 되는 것이다.

< [ ] >
 ㄱ.대괄호 안에 열거되어 있는 것 중 일치하는 문자열 1개 있을 때  
  grep Linux ch[12345] # 12(x) 123(x) -> 1,2,3,4,5 중에 ”한개“만 매칭됨
 ㄴ. Range: grep Linux ch[1-5]
 * 와일드 카드 주의할점: 파일이 없으면 오류 난다. 
2) 실습하기
Q1.짝수로 끝나는 모든 파일(chxxx)
A1ch.앞에 어떤 수가 오던 끝이 0,2,4,6,8이 오면 된다. 
->grep Linux ch*[24680]: 현재 디렉토리에서 "ch"로 시작하는 파일 중에서 "Linux"라는 단어를 포함하고 있으며, 파일 이름의 마지막 문자가 2, 4, 6, 8, 0 중 하나인 파일을 찾아 출력합니다.

Q2.대문자로 시작하고, 언더스코어 포함되어 있는 파이썬 파일 매칭
->ls [A-Z]*_*.py (o)
->grep Linux ch[A-Z]*_*.py -> grep이 검색 기능, ch[A-Z]*_*.py 얘 자체도 검색. 검색 중복되어서 틀림
Q3. /etc 디렉터리 안에 파일 확장자가 .conf인 파일 목록 조회하기
A3.ls /etc/ *.conf(A)---> (O) 
   ls –l /etc | grep “.conf” (B)---->(X): 중복되는 짓을 한 것 :ls가 파일을 출력하는 건데 
5..변수 
 1)변수평가 - 변수를 리터럴 값으로 치환하여 값을 평가함
 2) 변수명칭 
	ㄱ.$VAR - 이미 지정된 변수 
	 	 ㄱ) 예시: $HOME - 루트 디렉터리/ $USER - 사용자명
	ㄴ.$var - 사용자가 지정하는 변수
h ls $var(내가 이렇게 치면
	-> var=./notes/w3.txt (프퓨로그램은 이렇게 받아들인다는 건가)


3) echo/printenv
	ㄱ.변수의 내역 출력하기: printenv($없어도 된다) + 변수
    ex) ~/oss$ printenv HOME -> 출력값: /home/runner(유저명)-왜 유저명이 디렉터리 경로에 포함되나요
    ex) ~/oss$ printenv USER -> 출력값: runner(유저명)
	ㄴ.echo(프린트의 기능)
	  ㄱ) ~/oss$ echo HOME -> 출력값: /home/runner(유저명)->이건왜 디렉터리 경로처럼 출력이 되지 출력값이 그냥 HOME이래야 할 것 같은데
          ㄴ) 변수+텍스트도 가능 ->변수가 리터럴 값으로 변경된뒤 출력됨
		ex)~/oss$ echo my directory is  $HOME -> 출력값:my directory is /home/runner


4) 변수 설정하기
 ㄱ.변수이름 짓기
   name=변수에 대입할 값 ex)namee=lee
  -공백없어야함(공백이 생기면 그것을 프로그램으로 인식하기 때문)
  -변수=값(변수를 처음 설정할때는 $ 이 없다)
  -변수 사용:  "$변수명"(“”와 ‘’는 없어도 상관없다)
ㄴ.실습하기
Q. age라는 변수에 자신의 나이를 담고 "내나이는 ....살이다"를 변수를 이용해서 출력한다.
A. age=12
  echo my age is $age

ㄷ. 변수를 사용하는 경우
 - 자주 사용하는 디렉터리가 있을 때 
 ex) dir1=$HOME/notes/chapter1/ (HOME을 적어주는 것이 좋다) => &dir1 => cd $dir1


5) 패턴과 변수
ㄱ. 실습하기
	mammals
	 ㄴ lizard.txt    에서 lizard.txt와 snake.txt를 reptiles로 변수를 이용하여 옮기자
	 ㄴ snake.txt
	reptiles
* mv<from><to> 명령어 이용 :파일 또는 디렉토리를 이동하거나 이름을 변경
ex)디렉터리변경: $mv /home/runner/KYG/mammals/r  /home/runner/KYG
<from> 변경할 대상 /<to> 이동할 곳
->mv ch[1-4] ch[1-4].conf : 왜 안되냐
Q1.변수에 담아서 이동시키려면?
A1.dir1==mammals/*.txt
   mv $dir1 reptiles
Q2.패턴 매칭으로 이동시키려면?
A2.mv mammals/*.txt reptiles

dir2=“lizard.txt snake.txt” (x)
mv $dir2 reptile    
=> 두 txt파일을 하나로 인식한다. 이유?

6.alias(사전적 정의: 가명)
1)정의 :단축어를 별명으로 설정하기 
2) 어떻게 쓰냐
“ 나는 uniq 다음 –c를 많이 쓰는데 나는 uniq –c를 계속 쓰고 싶지 않아서 이를 변수로 만들고 싶다” =>alias uniqc="uniq –c"   ->사용법 : uniqc | ...(쌍따움표 무조건 써야함)

3)  alias 예시
 removeall=“rm –r”(-r:파일을 remove할 때 체크하거나 디렉터리 전체 삭제 할 때 쓰는 옵션)

4) shadowing
 ㄱ.정의 :원래 있는 애로 이름을 쓰는것
 ㄴ. 예시  ex1) alias grep="grep Linux *.txt"
           ex2) alias ls="ls -l"

5)alias조회하기/삭제하기
조회 –그냥 alias 치기 / 삭제 –unalias + 내가만든 alias 명

*ls –l = 자세한거 출력 / ls –1 :한줄한줄 출력 /ls = 파일명만 출력

<쌍따움표 정리>alias(별명) 짓기
디렉터리를 변수에 저장 할 때 그냥 변수 만들어서 저장할 때 쌍따움표 적어라  으휴 왜 까노

<와일드 카드>
[aeiou] = 콤마 금지
[02468]