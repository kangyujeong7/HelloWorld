키보드로표준입력을 넣어가지고 운영체제에서 뭔가를 하고 그 결과값을 표준 출력으로 보여줌
표준에러: "표준 출력(Standard Output)"과 별도로 처리되며, 일반적으로 화면에 직접 출력되는 것이 아니라 파일에 리다이렉션되거나 다른 프로세스에 파이프로 전달됩니다.

● 셸에서 상속되는 3개의 표준스트림
● 표준입력, 표준출력(터미널로 나감), 표준 오류(표준출력과 별개로 움직임)






=================
#1.리다이렉션
-표준 스트림이란?(컴퓨터 프로그램과 외부환경 사이의 입출력 통로)
 -파일을 읽고 쓰는 과정처럼 데이터를 입출력하는 것(유닉스의 특징)(데이터를 읽고쓰느건 파일입출력과 유사하다)
 -데이터가 연속적으로 흐른다는 특징
-키보드 ->운영체제 -> 디스 플레이(화면)   (= 표준스트림)                     
  -stdin
  -stdout
  -stderr
  -stdout/stderr는 서로 다른 방식으로(루트로) 츨력된다.(그림)

 -리다이렉션이란?
  -입출력 방향을 다른곳으로 바꾼다.(다이렉션을 바꾼다)
  -키보드에서 입력받지 않고 파일에서 받는 입력
  <->디스플레이로  받지 않고 파일에에다가 출력을 받는 (출력을 화면이 아닌 츨력이 파일에 저장되는)
   예:ls -ㅣ: 파일로 저장한다.
  - 셸의 역할이다(운영체제와 파일을 연결하는 작업. 우리와 연결하는 작업도 하지만....)

  1)출력 리다이렉션
    - 출력 내용을 표준 출력이 아닌 파일로 보내 저장하는 것(
    - 구조(syntax): 명령 >파일이름 (명령의 출력값이 파일로 저장되고 나한테는 아무것도 안보인다 / 기존에것도 가능 + 새로운 파일 만드는 것도 가능)
 * 파일의 내용을 열어 보는 방법
     1) head
     2)cat((concatenate의 줄인말 : "연속으로" 이어 붙인다.)
      -기능1:  파일 내용출력: 입력된 내용을 그대로 화면에 출력하는 명령(p.30)
 ex)cat *
      -기능2: 하나 이상의 파일을 다른 여러 종류의 파일과 연결할때 많이 사용 ex) 파일복사, 합침
         -파일 합치기:cat 파일이름 1,2,3,....ㅊ
              =파일 1+2+3(파일을 합친다)
             - 파일 1 2 
         - 파일 생성 >: 기존에 있는 파일 내용을 지우고 저장하고 ex) cat good > bad 하면 bad의 내용이 지워지고 good파일의 내용이 bad에 써진다.
      -추가 : >>(리다이렉션 2개):>> 기호를 사용하면 기존 파일 내용뒤에 연속해서 기록합니다. 
 3)less: 파일의 내용을 한 화면씩 나눠 출력하는 기능이 있다 나올떄는 q
 * ls 
    
  2)입력 리다이렉션
grep "pattern" < input_file

일의 내용을 명령어의 입력으로 제공하는 역할을 합니
입력 리다이렉션을 사용하여 "input_file"이라는 파일을 grep 명령어의 입력으로 제공합니다.
입력 리다이렉션을 사용하면 사용자가 키보드로 직접 입력하는 대신 파일의 내용을 명령어에 전달할 수 있습니다.
=============
  -명령 <파일 
  - wc animals.txt vs wc < animals.txt 의 차이  
  ->  파일 이름o             파일이름x
  전자: 프로그램이 파일의 존재를 알고 있음(파일에서 읽고 왔다는 것을 안다)
  후자: 셸이 한 리다이렉션 때문에 프로그램이 파일 존재 모름

  3) 리다이렉션이 불가능한 출력 
  - 표준오류는 리다이렉션이 불가능하다.ex) cp (copy) :없는 파일을 어떤 새로운 파일로 copy를 한다는 명령을 했는데 그런 텍스트가 없다는 에러 가 났다면, 이를 어떤 result에 담았다고 하면 그래도 에러가 뜸 result가 있기는 하지만 에러가 뜸, 지나가는 경로가 다르기 때문
  - 아예불가능하지는 않다 : 2>를 사용하면 리다이렉션이 가능함. ) (오류를 파일에 담아 준) 명령문 2> 파일이름  (명령문의 에럭 파일에 들어간다)
  * 2>> : 기존의 파일에 추가 명령문 2>> 기존 파일 ( 기존파일에 에러를 추가한다)
  - 표준 출력과 오류 같이 리다이렉션하려면? &>

    실습하기) 존재하는 파일과 존재하지 않는 파일 모두 읽어서 새로운 파일 만들자. 
    line1 .txt non.txt를 line 2.txt 에 쓰되, 존재하면 그 내용이 들어갈고 존재하지 않으면 에러가 뜨겠지 그 내용을 모두 리다이렉션 해라
 답:$ cat line1.txt non.txt &> line2.txt

 
4) 입출력 모두 다 같이
 - 명령< 입력 파일> 출력파일
  실습하기) animals.txt 에서 Perl 라인의 글자 (character) 수 세고 결과를 파일 result/입력도 리다이렉션(한번에)

-> grep Perl <  animals.txt | wc –c > result
 # 2.Escape Letters
  - 특정  문자가 가지고 있는 기능을 차단하게 해주는 기능
      예: \\n,\\t 
  종류1)\ (역슬래시,백슬래시)
  ex)echo "\$HOME" => $HOME  ( full directory 의 역할을 끄고 싶을 때 , 문자그대로 출력됨)
$ $HOME
bash: /home/runner: Is a directory

종류2)'' (작은 따움표)
 - 제일 강력한 역할
 - 안에 있는 모든 기능 해제함(작은 고추가 맵다)
EX)
입력 : $ echo 'this is a directory: $HOME'
출력:this is a directory: $HOME

종류3)""(큰따움표)
- 일부 기능은 해제하지 않는다.
EX)
입력:$ echo " this is a directory: $HOME"
 출력:this is a directory: /home/runner

 
종류4)) \(백슬래시)
 -기능:일부분을 지정해서 기능 해제 (문자그대로 읽게 함)
 - 사용1)큰 따움표 안에 큰따움표 사용하려면?
$ echo "home sweet home""
> 
>  => 라인이  계속 연결이 되고 안 끝난다. 
   => 어떻게 해야 할까?
 입력:$ echo "\" home sweet home\""
 출력:" home sweet home"
 - 사용2)파이프라인이 길어져읽기 힘들떄  \ +enter = 같은라인이라고 인식함             명령 줄 바꿔쓰기 할 때 많이 쓴다.
     EX) |\
         | grep ....\
         | head ....
      
사용 3) 별명 무효화 기능
           alias grep="grep -w"
           \grep -> 원래기능대로 나온다.
	ex) 
 	    \grep sally grep -> sallyjones2
# 3. 검색경로(설정에 관한 것)
 -/usr/bin(grep,cat,wc가 모두 이 디렉토리에 저장)
 - 검색경로/usr/bin은 $PATH 라는 변수에 저장 -> $echo $PATH
 실습하기 ) :  기준으로 개행 붙여서 출력하라 
 * tr<A><B> :A ->B 이용  
	- $echo $PATH | tr : \n (:을 다 n으로 바꾿다)
	=> \n이라는 문자열을 tr 명령어에 전달하고 있습니다. 이 때 \는 이스케이프 문자	로 작용하여 n 문자를 일반 문자로 취급합니다.(백슬리시+ 문자n)
	- $echo $PATH | tr : "\n“ (:을 다 \n으로 바꾼다)
	- $echo $PATH | tr : ‘\n’도 가능 

 -우리가 사용하는 프로그램이 저장되어 있는 경로
 -셸이 검색 경로를 순차적으로 순회하며 프로그램을 가져온다.(샐이 검색경로에 접근할 때 저장되어있는 순서대로 저장한다)\
 -  검색경로 확인 명령 : which, < type
 ex)내가 어떤 ls를 쓰는가:which ls
 - 둘의 차이?? type은 검색경로 뿐만 아니라 더 넓은 범위에서 경로 조회
 (별명까지/which는 pass만 돌아다니지만, type은 alias까지 찾는다.)
  - 별명이 검색경로를 우선한다.(별명이 있으면 별명을 가져오고 그게 아니면 pass를 탄다)

*검색 경로(search path)는 프로그램이나 명령어를 실행할 때 시스템이 해당 프로그램이나 명령어를 찾는 경로를 의미합니다. 대부분의 운영 체제에서는 특정 디렉터리들을 탐색하여 실행할 명령어나 프로그램을 찾습니다. 이 디렉터리들의 집합을 검색 경로라고 합니다.

일반적으로 시스템은 환경 변수인 PATH를 사용하여 검색 경로를 정의합니다. PATH 변수에는 여러 디렉터리 경로가 콜론(:)으로 구분되어 나열됩니다. 이 디렉터리들을 시스템은 왼쪽에서 오른쪽으로 순서대로 탐색하여 명령어나 프로그램을 찾습니다.

예를 들어, ls 명령어를 실행하면 시스템은 PATH 변수에 정의된 디렉터리들을 순차적으로 탐색하여 ls 명령어를 찾습니다. 일반적으로 /bin, /usr/bin, /usr/local/bin 등의 디렉터리가 PATH 변수에 포함됩니다.

검색 경로를 이해하면 시스템이 명령어나 프로그램을 어디서 찾는지 이해할 수 있습니다.
  
  # 4. 초기화 파일(설정에 관한 것)
  -  shell environment (초기화 파일):어떤 변수들이 셸을 켰을때 저장되어있을때, 내가 셸을 켤때마다 그 변수들이 저장되어있게 하고 싶은 것 그런내용을 담는 파일을  초기화 파일
  - 'ls -a $HOME' # -a :숨겨진 파일까지 모두 출력(a인자는 all을 말함) (.bashrc)bashr
 - 환경설정 파일의 위치:$ HOME/.bashrc($HOME 환경 변수의 값인 사용자의 홈 디렉토리를 나타내고, 그 아래에 있는 .bashrc 파일을 가리킵니다. )
  - $ HOME/.bashrc을 vi 로 파일 열기 : vi  $ HOME/.bashrc
  - source
  -  사용자가 자주 사용하는 환경 설정을 저장하며 항상 셸을 켤 때 마다 적용되도록 한다.
   => 실습하기 ) 자주사용하는 환경설정을 저장해보자
1. 환경설정파일열기: $ HOME/.bashrc을 vi 로 파일 열기 => vi  $ HOME/.bashrc(vi =vm)
2. 거기에 w4의 문서편집기의 방식으로 파일열기
3. echo This is my customized setting $USER 치기
4.:wq!+enter”로  파일 빠져나갈 것 
5. 적용하자 : source 명령어를 쓰자 => $source $ HOME/.bashrc 
=>이때 다른 색깔이 뜨는데   이는 셸이 바뀐 것이다, 이전 셸과 다른데 이전 셸에는 내 설정이 먹히지 않았던 것이고 이것은 내설정이 먹힌 것이다. 새로 창을 켰다고 생각해라 

  # 5.명령 히스토리( command history)
  - 우리가 커맨드라인에 입력한 명령들을 셸이 저장해서 가지고 있다.
  -히스토리를 사용해서 이전 명령을 불러와 재사용하는 기능을 익힌다.
  ##1) 히스토리 열람 ,삭제
  -여는방법 그냥 $hisotry
  -특징: LIFO(last in first out): 마지막에 했던 것이 제일 위에 올라와있어서, 내가 방향키 ↑를 눌렀을 때 제일 마지막에 했던 명령이 뜬다.
  -내가 검색하고 싶은 개수를 정하자 :$history 10 
=> 총 hisroty 가 1-27개라고 하면 18~27이 출력된다.
- 삭제: history –c( 모두 다 지우는 거다) 
  Q. 히스토리를 가장 처음부터 10개 출력하기 + 한 화면에
  A.history | head | less(=한화면에)
  Q. 전체 히스토리에서 echo만 출력하기 
  A. $history | grep –w echo (-w를 써서 echo 머시기머시기가 포함 안되도록하자)
 


빠르다
느리다
간단하다
증분검색
커서링
까다롭다
히스토리 확장





‘
 ##2) history 재사용 (1-.>3으로 갈수록 어렵고 편하다)


  1.커서링                              
  2.히스토리 확장
  3. 증분 검색
  ###1. 커서링(방향키)
  -위아래 키를 사용하여 히스토리 열람
  -간단하지만 느림 -> 이전 2~3개 명령일 경우 사용(계속↑를 눌러야 돼서)
  -입력한 역순으로 이전 명령을 불러옴
  몇 개까지?(HISTSIZE 히스토리에 저장되는 명령어의 최대 수를 지정)
  -$HISTSIZE 설정하면된다. => replit에 default로 얼마인지 보자, =>$echo $HISTSIZE
    * $HISTSIZE=-1 (무한 저장)
  반복되는 명령은?
  -$HISTCONTROL=ignoredups # 중복되는 명령어 하나만 저장(HISTCONTROL은  환경 변수는 셸에서 이전 명령어 기록을 관리하는 데 사용)(전 명령어와 중복된 명령어는 히스토리에 저장되지 않도록 하는 옵션입니다.)
  - 모든 명령 히스토리는  파일 $HISTFILE에 저장된다.(내가 처음에 시작했던 깃부터 시작헤서 다 저장이 되고 있다. 몇 개까지 HISTSIZE만큼)
  ###2. 히스토리 확장(커서링 과 히스토리 확장의 가장 큰 차이는 히스토리 확장은 실행까지 한다)
  - 특별한 표현식을 활용하는 방법 : 히스토리 확장은 느낌표기호로 시작
  -명령을 가져오고 실행까지 함

  -!!:바로이전명령 ’실행‘(이전에 주었던 명령어가 출력되고 명령어를 실행했을 때의 값이 출력)
  -!<명령어>:가장 마지막에 한 특정 명령 가져와서 ‘실행’ ex)!grep
  - 커서링과 히스토리 확장의 차이는 히스토리 확장은 실행까지 한다가 큰 차이다
  -!70(히스토리 번호) : 70을 가져와 서 실행한다.

  -!-3(음수도 가능) : 밑에서부터 거꾸로(최근부터)(딱 –3번째것만 출력)
  -장점:쉽다
  -단점:실행까지 되기 때문에 조심할 것/내가 번호를 알려면 조회해야 되는데 귀찮다.
   - :P – 확인 (어떤 명령인지 명령어만 출력하고 실제 실행되지는 않는다)
   ex) !-3:p (!-3이 어떤 명령어인지 확인)
   




실습하기) 이전 명령의 단어(word) 수 세기(표현식 활용)
-> !!| wc –w 
=> stdout 으로 활용할 수 있다는 점(표준출력을 받아서 명령어로 쓸수 있다는 점을  히스토리 확장을 통해 알고 싶었다)

실습하기)
!?grep?는 히스토리에서 특정 단어를 포함하는 명령어를 찾아 실행하는
 !grep은 특정한 명령어를 직접 실행



-파일 삭제할 때
 - !$ : 이전 명령의 마지막 내용(인수)(검사: 이전 명령어의 마지막 인자를 재사용
ex) ls –l/etc 일떄, !$=/etc
ex)head file 일 때, !$=file

  -alias rm='rm -i' #삭제하기 전에 확인하라 (rm=파일 삭제하는 것)
  -!* : 인수 2개 이상일 경우 매칭(파일이 여러개 일 때 )
ex)cat ch1 ch2 => !*

###3. 증분 검색(키워드 카드/ 명령의 앞부분만 입력해도 나머지 부분이 자동으로 입력된다)(걍 책봐라)
- ctrl + R =>  셸 스크립트에 (reverse-i-search)`': 가 뜨는데  여기다가 단어를 쓰면 첫번
- enter
----------
- ctrl + j,c,
- ESC



-요약
  - 명령행 편집 효율적으로 잘하자.
===============
[치환표현식]
1.케럿을 이용한 히스토리 확장
1)md5sum *.jg | ... | ...
-> 파이프라인이 많아서 수정하기 힘들다면
^jp^jpg

2)<패턴>:s/from_cmd/to_cmd
=> !! :s/jg/jpg ( !!를 사용하여 이전 명령을 실행하고,, ":s/jg/jpg" 부분은 해당 명령에서 "jg"라는 문자열을 "jpg"로 바꾸는 것을 의미  )
=> ! md5sum:s/jg/jpg

!! :s/jg/jpg




$ history | sort –nr | less (최근것부터 보기)    
60
59
58
$history | grep –w cd
